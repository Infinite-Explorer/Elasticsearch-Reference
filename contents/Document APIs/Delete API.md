### 删除 API

删除API可以通过JSON 文档的id将其从指定的索引下的一个类型中删除。下面的例子演示了如何从索引twitter下的类型tweet中将id为1的JSON文档删除：

> **curl -XDELETE 'http://localhost:9200/twitter/tweet/1'**

返回结果：

> **<pre>
{
    "_shards" : {
        "total" : 10,
        "failed" : 0,
        "successful" : 10
    },
    "found" : true,
    "_index" : "twitter",
    "_type" : "tweet",
    "_id" : "1",
    "_version" : 2
}
> </pre>**

### 版本控制

每个被索引的文档都有版本。指定`version`参数可以确保我们删掉了想删掉的文档并且文档同时没有改变。文档的每一个写操作，包括删除操作都会造成文档的版本递增。

### 路由

如果在索引文档的时候使用了路由值，那么在删除文档的时候也需要提供该路由值。例如：

> **curl -XDELETE 'http://localhost:9200/twitter/tweet/1?routing=kimchy'**

上面的命令会删除基于用户名路由的id为1的推文。注意，删除时使用了错误的路由值并不能成功删除文档。

如果`_routing`映射设为`required`并且删除文档的时候不传路由值，删除API就会抛出一个`RoutingMissingException`异常并决绝删除请求。

### 父文档

可以设置`parent`参数，其跟设置路由参数基本相同。

注意，删除父文档并不会自动删除其子文档。一种通过父文档id删除其下所有子文档的方法是使用`delete-by-query`插件在带有自动生成（和索引）的_parent字段的子文档索引上执行删除操作，格式为parent_type#parent_id。


删除一个子文档必须提供其父文档id，否则会拒绝删除请求并抛出`RoutingMissingException`异常。

### 自动创建索引

如果在之前没有创建索引，那么删除操作就会自动创建索引（查看创建索引API中的手动创建索引部分），如果在之前没有创建类型也会根据传入的类型自动创建一个动态类型映射（查看创建映射API中的手动创建类型映射部分）。

### 分布式

删除操作通过哈希得到一个具体的分片id。然后会在该id组中的主分片执行删除操作，接着在id组中的副本分片上执行相同的删除操作（如果有必要的话）。

### 写一致性

删除操作能否执行取决于在对应的分区（分片组）中激活的分片数量。可选的值为：`one`,`quorum`,`all`。设置该值的参数为`consistency`，默认为节点级别的设置`action.write_consistency`，默认值为`quorum`。

举例来说，在一个有N个主分片，2个副本分片的索引来说，在相应的分区中至少需要有2个激活的分片，删除操作才能执行成功。对于一个有N个分片，1个主分片的情况，只需要一个激活的分片就行（在这种情况下，`one`和`quorum`是一样的）。

### 刷新
通过将`refresh`参数可以设成`true`可以在删除操作执行之后刷新主分片和副本分片使其可搜索。在设为`true`之前应该深思熟虑和验证会不会导致系统高负载（和索引缓慢）。

### 超时

被分配去执行删除操作的主分片在执行删除操作任务的时候可能并不能执行。这其中的原因可能是该主分片正在从网关恢复或者是正在重新分配数据中。默认的，删除操作在失败或者返回一个错误之前会等待该分片成为可用状态直到1分钟。`timeout`参数可以用来指定等待的具体时长。下面是设置等待时长为5分钟的例子：

> **$ curl -XDELETE 'http://localhost:9200/twitter/tweet/1?timeout=5m'**